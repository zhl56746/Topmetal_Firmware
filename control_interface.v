//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 3? 13 2019 14:50:53
//
//      Input file      : 
//      Component name  : control_interface
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

// $Id$
//-----------------------------------------------------------------------------
// Title      : Control Interface
// Project    : HFT PXL
//-----------------------------------------------------------------------------
// File       : control_interface.vhd
// Author     : JS  <jschamba@physics.utexas.edu>
// Company    : University of Texas at Austin
// Created    : 2013-06-12
// Last update: 2013-10-25
// Platform   : Windows, Xilinx PlanAhead 14.5
// Target     : Virtex 6 (XC6VLX240T-FF1759)
// Standard   : VHDL'93/02
//-----------------------------------------------------------------------------
// Description: Read words from command FIFO and interpret
//              This defines some example interfaces at different addresses:
//              Address 32 - 63:         16bit Configuration registers
//                              These registers can be written and read.
//                              Could be used to define operations parameters
//              Address 11:             16bit Pulse REGISTER
//                              This register generates a pulse at the bits
//                              set to 1 that is 3 clocks wide
//                              Could be used to start some action, e.g. jtag
//              Address 0 - 10:        16bit Status registers
//                              These are read-only.
//                              Can be used to read the status of some external
//                              device, .e.g an ADC, or input pins.
//              Address 16 - 20:        32bit memory interface
//                              The idea is to write an address into 17 (LSB)
//                              and 18 (MSB)
//                              Then write the LSB16 into 19, and finally
//                              the  MSB16 into 20. On write to 20, the 32bit
//                              data in 19 and 20 is written to the memory, AND
//                              the address is auto-incremented, so that the NEXT
//                              write seuqence doesn't need to re-write the address.
//                              A Read on 20 reads the current address and returns
//                              a 32bit data word into the FIFO, then increases
//                              the memory. This read is repeated n times, where
//                              "n" is the 16bit value at address 16.
//              Address 25:     This address cmdstate_initiates a read from the DATA_FIFO
//                              The value writen n indicated the number of
//                              words to copy from the DATA_FIFO to the FIFO
//                              (fifo to the USB interface) -- low 16bit
//             Address 26:     High 14 bit for number of FIFO readout
//-----------------------------------------------------------------------------
// Copyright (c) 2013 
//-----------------------------------------------------------------------------
// Revisions  :
// Date        Version   Author          Description
// 2013-06-12   1.0      jschamba        Created
// 2013-10-21   1.1      thorsten        changed memory address space to 32 bit
//                                       added an interface to read a data fifo
// 2015-06-01   1.2      Dong            Fifo readout address incress to 30 bit
// 2019-03-11   1.4      Z-H-L           Convered to Verilog
//-----------------------------------------------------------------------------

//  Entity Declaration
module control_interface(
	reset,
	clk,
	fifo_q,
	fifo_empty,
	fifo_rdreq,
	fifo_rdclk,
	cmd_fifo_q,
	cmd_fifo_empty,
	cmd_fifo_rdreq,
	config_reg,
	pulse_reg,
	status_reg,
	mem_we,
	mem_addr,
	mem_din,
	mem_dout,
	data_fifo_q,
	data_fifo_empty,
	data_fifo_rdreq,
	data_fifo_rdclk
);
	input            	reset;
	input            	clk;				// system clock
	// From FPGA to PC
	output 	[35:0]    	fifo_q;		    	// interface fifo data output port
	output           	fifo_empty;			// interface fifo "emtpy" signal
	input            	fifo_rdreq;			// interface fifo read request
	input            	fifo_rdclk;			// interface fifo read clock
	// From PC to FPGA, FWFT
	input 	[35:0]   	cmd_fifo_q;			// interface command fifo data out port
	input            	cmd_fifo_empty;		// interface command fifo "emtpy" signal
	output reg       	cmd_fifo_rdreq;		// interface command fifo read request
	// Digital I/O
	output 	[511:0]  	config_reg;			// thirtytwo 16bit registers
	output 	[15:0]   	pulse_reg;			// 16bit pulse register
	input 	[175:0]  	status_reg;			// eleven 16bit registers
	// Memory interface
	output           	mem_we;				// memory write enable
	output 	[31:0]   	mem_addr;
	output 	[31:0]   	mem_din;			// memory data input
	input 	[31:0]   	mem_dout;			// memory data output
	// Data FIFO interface, FWFT
	input 	[31:0]   	data_fifo_q;
	input            	data_fifo_empty;
	output           	data_fifo_rdreq;
	output           	data_fifo_rdclk;
	
	// Architecture body
	
	// signals for FIFO
	integer          	bmemnotreg;
	parameter        	SEL_REG = 0;
	parameter        	SEL_MEM = 1;
	parameter        	SEL_FIFO = 2;
	wire 	[35:0]   	sfifod;
	wire             	sfifofull;
	reg              	sfifowrreq;
	wire             	sfiforst;
	wire             	sfifoclk;
	
	// signals for single-port RAM
	reg              	swea;
	reg 	[31:0]   	saddra;
	wire 	[31:0]   	sdina;
	wire 	[31:0]   	sdouta;
	reg 	[15:0]   	sdinreg;
	reg 	[15:0]   	smemiocnt;
	wire 	[31:0]   	smemlatch;
	
	// Configuration registers: 8 x 16bit
	reg 	[511:0]     sconfigreg;
	reg 	[15:0]      spulsereg;
	reg 	[15:0]      sregout;
	
	// signals for FIFO read
	// to read data from a FIFO
	wire 	[15:0]      sdatafifocount;
	reg              	sdatafifordreq;
	reg 	[15:0]      sdatafifohigh;
	//reg 	[11:0]      address_i;
	//reg 	[15:0]      counterv;
	//reg 	[29:0]      counterfifo;
	
	// State machine variable
	parameter [2:0]  cmdstate_init 			= 0,
					 cmdstate_wait_cmd 		= 1,
					 cmdstate_get_cmd 		= 2,
					 cmdstate_interpret_cmd = 3,
					 cmdstate_mem_adv 		= 4,
					 cmdstate_mem_rd_cnt 	= 5,
					 cmdstate_pulse_delay 	= 6,
					 cmdstate_fifo_adv 		= 7;
	reg [2:0]        cmdstate;
	
	assign config_reg 		= sconfigreg;
	assign pulse_reg 		= spulsereg;
	assign mem_we 			= swea;
	assign mem_addr 		= saddra;
	assign mem_din 			= sdina;
	assign sdouta 			= mem_dout;
	
	// memory input
	assign sdina[15:0] 		= sdinreg;
	assign sdina[31:16] 	= cmd_fifo_q[15:0];
	
	// data fifo
	assign data_fifo_rdclk 	= (~clk);
	assign data_fifo_rdreq 	= sdatafifordreq;
	
	// data/event FIFO
	assign sfiforst 		= reset;
	assign sfifoclk 		= (~clk);
	
	fifo36x512 data_fifo  (
		.rst(sfiforst),
		.wr_clk(sfifoclk),
		.rd_clk(fifo_rdclk),
		.din(sfifod),
		.wr_en(sfifowrreq),
		.rd_en(fifo_rdreq),
		.dout(fifo_q),
		.full(sfifofull),
		.empty(fifo_empty)
	);
	
	assign sfifod[35:32] 	= {36{1'b0}};		// these bits not used
	assign sfifod[31:0] 	= (bmemnotreg == SEL_MEM) ? mem_dout : 
						  		(bmemnotreg == SEL_FIFO) ? data_fifo_q : 
						  		{16'h0000, sregout};
	
	
	always @(posedge clk or posedge reset)
	begin: cmdIF_inst
		reg 	[15:0]      counterv;
		reg 	[11:0]      address_i;
		reg 	[29:0]      counterfifo;
		if (reset == 1'b1) begin
			counterv 		<= 0;
			cmdstate 		<= cmdstate_init;
			cmd_fifo_rdreq 	<= 1'b0;
			sconfigreg 		<= {512{1'b1}};
			spulsereg 		<= {16{1'b0}};
			sdinreg 		<= {16{1'b0}};
			smemiocnt 		<= {16{1'b0}};
			swea 			<= 1'b0;
			saddra 			<= {32{1'b0}};
			bmemnotreg 		<= SEL_REG;
		
		end else  begin
			// defaults:
			cmd_fifo_rdreq 	<= 1'b0;
			sfifowrreq 		<= 1'b0;
			swea 			<= 1'b0;
			sregout 		<= {16{1'b0}};
			sdatafifordreq 	<= 1'b0;
			
			case (cmdstate)
				//      //// cmdstate_initialize registers to some sensible values
				cmdstate_init :
					begin
						// currently all 0
						sconfigreg 	<= {512{1'b1}};
						spulsereg 	<= {16{1'b0}};
						saddra 		<= {32{1'b0}};
						// at least 1 memory read
						smemiocnt 	<= 16'h0001;
						cmdstate 	<= cmdstate_wait_cmd;
					end
				
				//      //// Wait for CMD_FIFO words
				cmdstate_wait_cmd :
					begin
						bmemnotreg 	<= SEL_REG;		// output registers
						spulsereg 	<= {16{1'b0}};		// reset pulse REGISTER
						// wait for FIFO not empty
						if (cmd_fifo_empty == 1'b0) begin
							cmd_fifo_rdreq 	<= 1'b1;
							cmdstate 		<= cmdstate_interpret_cmd;		// cmdstate_get_cmd;
						end 
					end
				
				//      //// one wait state to get next CMD_FIFO word
				// When FWFT FIFO is used, this state should be skipped.

				//      //// Now interpret the current CMD_FIFO output
				cmdstate_interpret_cmd :
					begin
						//-------------------------------------------------------------------
						// CMD_FIFO_Q format:
						// Q(31)      : READ/NOT_WRITE
						// Q(30:28)   : not used
						// Q(27:16)   : ADDRESS
						// Q(15:0)    : DATA
						//-------------------------------------------------------------------
						
						address_i = ((cmd_fifo_q[27:16]));
						if (cmd_fifo_q[31] == 1'b1)
							// //// a READ transaction ////////
							casez (address_i)
								8'b001?_???? :		// CONFIG_REG,rang is 32 to 63
									begin
										sregout 	<= sconfigreg[((cmd_fifo_q[27:16] - 32) * 16 + 15) -: 16];
										sfifowrreq 	<= 1'b1;
										cmdstate 	<= cmdstate_wait_cmd;
									end
								
								//8'd1,8'd2,8'd3,8'd4,8'd5,8'd6,8'd7,8'd8,8'd9:		// STATUS_REG
								8'b0000_???? : // Here rang is 0 to 10, some nummber is not use.
									begin
										sregout 	<= status_reg[(cmd_fifo_q[27:16] * 16 + 15) -: 16];
										sfifowrreq 	<= 1'b1;
										cmdstate 	<= cmdstate_wait_cmd;
									end
								//8'd10 :
								//	begin
								//		sregout 	<= status_reg[(cmd_fifo_q[27:16] * 16 + 15) -: 16];
								//		sfifowrreq 	<= 1'b1;
								//		cmdstate 	<= cmdstate_wait_cmd;
								//	end
								8'b0001_0000 :		// 16, memory count REGISTER
									begin
										sregout 	<= smemiocnt;
										sfifowrreq 	<= 1'b1;
										cmdstate 	<= cmdstate_wait_cmd;
									end
								
								8'b0001_0001 :		// 17, memory address LSB REGISTER
									begin
										sregout 	<= (saddra[15:0]);
										sfifowrreq 	<= 1'b1;
										cmdstate 	<= cmdstate_wait_cmd;
									end
								
								8'b0001_0010 :		// 18, memory address MSB REGISTER
									begin
										sregout 	<= (saddra[31:16]);
										sfifowrreq 	<= 1'b1;
										cmdstate 	<= cmdstate_wait_cmd;
									end
								
								8'b0001_0100 :		// 20, read sMemioCnt 32bit memory words
									begin
										// reads 32bit memory words starting at the current
										// address sAddrA
										counterv = smemiocnt;
										bmemnotreg 	<= SEL_MEM;		// switch FIFO input to memory output
										if (sfifofull == 1'b0) begin
											sfifowrreq 	<= 1'b1;		// latch current memory output
											saddra 		<= saddra + 1;		// and advance the address
											cmdstate 	<= cmdstate_mem_rd_cnt;
										end 
									end
								
								default :		// bad address, return FFFF
									begin
										sregout 	<= {16{1'b1}};
										sfifowrreq 	<= 1'b1;
										cmdstate 	<= cmdstate_wait_cmd;
									end
							endcase
						else
							
							// //// a WRITE transaction ////////
							casez (address_i)
								8'b001?_????:		// CONFIG_REG, Here rang is 32 to 63
									begin
										sconfigreg[((cmd_fifo_q[27:16] - 32) * 16 + 15) -: 16] <= cmd_fifo_q[15:0];
										cmdstate 	<= cmdstate_wait_cmd;
									end
								
								8'b0000_1011 :		//11, PULSE_REG
									begin
										spulsereg 	<= cmd_fifo_q[15:0];
										counterv 	<= 2;		// 60ns
										cmdstate 	<= cmdstate_pulse_delay;
									end
								
								8'b0001_0000 :		//16, memory count REGISTER
									begin
										smemiocnt 		<= cmd_fifo_q[15:0];
										cmdstate 		<= cmdstate_wait_cmd;
									end
								
								8'b0001_0001 :		//17, memory address LSB REGISTER
									begin
										saddra[15:0] 	<= (cmd_fifo_q[15:0]);
										cmdstate 		<= cmdstate_wait_cmd;
									end
								
								8'b0001_0010 :		//18, memory address MSB REGISTER
									begin
										//sAddrA   <= CMD_FIFO_Q(15 DOWNTO 0);
										saddra[31:16] 	<= (cmd_fifo_q[15:0]);
										cmdstate 		<= cmdstate_wait_cmd;
									end
								
								8'b0001_0011 :		//19, memory LS16B
									begin
										sdinreg 		<= cmd_fifo_q[15:0];
										cmdstate 		<= cmdstate_wait_cmd;
									end
								
								8'b0001_0100 :		//20, memory MS16B
									begin
										// raise WriteEnable for one clock, which clocks IN
										// register 18 as LS16B and the data content of
										// the CMD_FIFO word as MS16B
										swea 			<= 1'b1;
										cmdstate 		<= cmdstate_mem_adv;
									end
								
								8'b0001_1001 :		//25, Data Fifo read count
									begin
										counterfifo = (({sdatafifohigh[13:0], cmd_fifo_q[15:0]}));
										bmemnotreg <= SEL_FIFO;
										if (data_fifo_empty == 1'b0 & counterfifo > 0)
											cmdstate <= cmdstate_fifo_adv;
										else
											cmdstate <= cmdstate_wait_cmd;
									end
								
								8'b0001_1010 :	//26
									begin
										sdatafifohigh 	<= cmd_fifo_q[15:0];
										cmdstate 		<= cmdstate_wait_cmd;
									end
								
								default :		// bad address, do nothing
									cmdstate <= cmdstate_wait_cmd;
							endcase
					end
				
				//      //// advance memory address
				cmdstate_mem_adv :
					begin
						saddra 		<= saddra + 1;
						cmdstate 	<= cmdstate_wait_cmd;
					end
				
				//      //// read sMemioCnt memory addresses
				cmdstate_mem_rd_cnt :
					begin
						counterv = counterv - 1;
						// wait for FIFO not FULL
						if (counterv == 0)
							// Done
							cmdstate <= cmdstate_wait_cmd;
						else if (sfifofull == 1'b0) begin
							// latch current memory output
							sfifowrreq 	<= 1'b1;
							// and advance address
							saddra 		<= saddra + 1;
							cmdstate 	<= cmdstate_mem_rd_cnt;
						end 
						else begin
							// FIFO Full:
							// go back to previous count and wait for FIFO not full
							counterv 	<= counterv + 1;
							cmdstate 	<= cmdstate_mem_rd_cnt;
						end
					end
				
				//      //// delay two clocks to keep pulse high (total 3 clocks)
				cmdstate_pulse_delay :
					begin
						counterv = counterv - 1;
						if (counterv == 0)
							cmdstate 	<= cmdstate_wait_cmd;
					end
				
				//      //// Data FIFO read
				cmdstate_fifo_adv :
					// read data fifo, write reads to output fifo
					// exit when enough words were transferred
					// DATA_FIFO_EMPTY prematurely terminates the transfer
					if (data_fifo_empty == 1'b0) begin
						cmdstate <= cmdstate_fifo_adv;
						if (sfifofull == 1'b0) begin
							if (counterfifo == 0)
								// we are done
								cmdstate 		<= cmdstate_wait_cmd;
							else begin
								// more to copy
								sfifowrreq 		<= 1'b1;
								sdatafifordreq 	<= 1'b1;
								counterfifo 	<= counterfifo - 1;
							end
						end 
					end 
				
				//      //// shouldn't happen
				default :
					cmdstate <= cmdstate_wait_cmd;
			endcase
		end 
	end
	
endmodule
